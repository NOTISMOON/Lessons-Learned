## 一、React 16.3 及之前（Class Component 生命周期）

### 1. **挂载阶段（Mounting）**

```markdown
constructor()
↓
componentWillMount() （16.3后弃用，改名为UNSAFE_componentWillMount）
↓
render()
↓
componentDidMount()
```

### 2. **更新阶段（Updating）**

- 

  **props 更新：**

```markdown
componentWillReceiveProps() （16.3后弃用，改名UNSAFE_componentWillReceiveProps）
↓
shouldComponentUpdate()
↓
componentWillUpdate() （弃用，改名UNSAFE_componentWillUpdate）
↓
render()
↓
componentDidUpdate()
```

- 

  **state 更新：**

```markdown
shouldComponentUpdate()
↓
componentWillUpdate() （弃用）
↓
render()
↓
componentDidUpdate()
```

### 3. **卸载阶段（Unmounting）**

```markdown
componentWillUnmount()
```

### 4. **错误处理（Error Boundary）**

```markdown
componentDidCatch() （React 16新增）
```

------

## 二、React 16.3+ 新生命周期（Class Component）

React 16.3 引入了新生命周期，废弃了几个带副作用的生命周期方法：

### 新增方法：

- 

  **static getDerivedStateFromProps(props, state)**

  - 

    在 render 前调用，每次都会触发

  - 

    返回一个对象来更新 state，或 null 不更新

- 

  **getSnapshotBeforeUpdate(prevProps, prevState)**

  - 

    在 DOM 更新前调用

  - 

    返回值会作为 componentDidUpdate 的第三个参数

### 更新流程：

```markdown
static getDerivedStateFromProps()
↓
shouldComponentUpdate()
↓
render()
↓
getSnapshotBeforeUpdate()  // DOM 更新前
↓
React 更新 DOM
↓
componentDidUpdate()
```

------

## 三、React 16.8+ Hooks（Function Component）

### 主要 Hook 对应关系：

| Class 生命周期        | Hooks 替代方案                                |
| --------------------- | --------------------------------------------- |
| constructor           | useState 初始化                               |
| componentDidMount     | `useEffect(() => {...}, [])`                  |
| componentDidUpdate    | `useEffect(() => {...})`（无依赖数组）        |
| componentWillUnmount  | `useEffect(() => { return () => {...} }, [])` |
| shouldComponentUpdate | `React.memo`, `useMemo`                       |
| componentDidCatch     | 暂无直接对应，可用 Error Boundary             |

### 常用 Hooks：

```jsx
// 1. 状态管理
const [state, setState] = useState(initialState);

// 2. 副作用（生命周期替代）
useEffect(() => {
  // componentDidMount + componentDidUpdate
  
  return () => {
    // componentWillUnmount
  };
}, [dependencies]); // 依赖数组控制执行时机

// 3. 性能优化
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
const memoizedCallback = useCallback(() => { doSomething(a, b); }, [a, b]);

// 4. 上下文
const value = useContext(MyContext);

// 5. Ref
const ref = useRef(initialValue);
```

------

## 四、执行顺序对比示例

### Class Component：

```jsx
// 挂载
constructor → getDerivedStateFromProps → render → componentDidMount

// 更新
getDerivedStateFromProps → shouldComponentUpdate → render → 
getSnapshotBeforeUpdate → componentDidUpdate
```

### Function Component with Hooks：

```jsx
// 每次渲染
1. 运行函数组件
2. 按顺序执行所有 Hook
3. useEffect 的清理函数（如果需要）
4. useEffect 的执行函数（在浏览器绘制后）
```